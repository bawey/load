/** STRUCTURE **/
@Description('')
create variable long deadRateTimeout=10000;

create variable int bxBucketsLimit = 10;
create variable int bxDetailsLimit = 30;

create variable int trgBucketsLimit = 10;
create variable int trgDetailsLimit = 30;


@Description('Store the L1 zero rates and their timestamps as they come and flush whenever a non-zero comes')
create window L1DeadRates.win:expr(newest_event.rate=0) as select * from L1Rates;

@Description('Vital to satisfy patterns syntactic whims')
create window FrlCtlLnkSnapshot.std:unique(fedId) as select * from FrlCtlLnk;


create variable boolean printBxBuckets = false;

create schema BxMismatch as (timestamp Long, duration Long, bxNumbers Long);
/** LOGIC **/
insert into FrlCtlLnkSnapshot select * from FrlCtlLnk;


@Description('Store the L1 zero rates and their timestamps as they come and flush whenever a non-zero comes')
insert into L1DeadRates select * from L1Rates;

insert into BxMismatch
select distinct count(distinct ctl.bxNumber) as bxNumbers, max(deads.timestamp)-min(deads.timestamp) as duration, max(deads.timestamp) as timestamp from FrlCtlLnk.std:unique(fedId) as ctl,
	L1DeadRates as deads
	where deads.countOf()>0
	having max(deads.timestamp) is not null and count(distinct ctl.bxNumber) is not null 
	and count(distinct ctl.bxNumber) > 1
	and max(deads.timestamp)-min(deads.timestamp) > deadRateTimeout;

on BxMismatch set printBxBuckets=true;


/** OUTPUT **/

@Priority(10)
@Verbose(label='BxMismatches')
select * from BxMismatch;

@Priority(9)
@Verbose(label='BxMismatches')
select count(ctl.fedId) as support, ctl.bxNumber as bxNumber, max(deads.timestamp) as deadsTimestamp, max(ctl.timestamp) as fedTimestamp 
	from FrlCtlLnk.std:unique(fedId) as ctl, L1DeadRates as deads
	group by bxNumber
	having max(deads.timestamp) is not null;

@Description("Prints all the feds with deviating bxNumber")
select * from FrlCtlLnk;
/** WILD GUESS **/
