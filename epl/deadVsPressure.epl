/**
create window BpFeds.win:keepall() as (id Integer);
create window DtFeds.win:keepall() as (id Integer, kontext String, geoslot Integer, io Integer);

@Description('naively hold bp-guilty feds')
on pattern[every c=BackpressureAlarm(title='frl backpressure')] insert into BpFeds(id) select HwInfo.getInstance().getFedId(c.kontext, c.slotNumber, c.linkNumber, CmsHw.FRL) 
	where HwInfo.getInstance().getFedId(c.kontext, c.slotNumber ,c.linkNumber ,CmsHw.FRL) is not null;
@Verbose(label='BpFeds', extraNfo='sth deleted!')
on BackpressureFilter(bpFraction=0) as bf delete from BpFeds as bfeds where bfeds.id = HwInfo.getInstance().getFedId(bf.kontext, bf.slotNumber, bf.linkNumber, CmsHw.FRL);

		 * seems really hard to retrieve the set of Ids and use them to instantiate events, so we'll go around

select c.* from pattern[every c=Conclusions(title='deadtime')] ", new UpdateListener() {
			@Override
			public void update(EventBean[] newEvents, EventBean[] oldEvents) {
				Map<?, ?> attrs = (Map<?, ?>) newEvents[0].getUnderlying();
				Collection<Integer> fedIds = HwInfo.getInstance().getDeadtimeRelevantFedIds(attrs.get("kontext"), attrs.get("geoslot"), attrs.get("io"));
				console("e(x)", fedIds.toString());
				for (Integer id : fedIds) {
					Map<Object, Object> map = new HashMap<Object, Object>();
					map.put("id", id);
					map.putAll(attrs);
					ep.getRuntime().sendEvent(map, "DtFeds;
				}
			}
		});
on FMMInput(fractionWarning=0, fractionBusy=0) as fmi delete from DtFeds as dtf where"
				+ " kontext=fmi.context and dtf.geoslot=fmi.geoslot and dtf.io=fmi.io;

select count(*) as dtFeds from DtFeds", watchUpdater);

select id as dtFedId, kontext, geoslot, io from DtFeds", consoleLogger);

		createConclusionStream(ep, "misFEDs", "(title String, fedId int);
on pattern[ every bfed=BpFeds or dfed=DtFeds ] "
				+ "insert into misFEDs select 'backpressure and deadtime' as title, bfed.id as fedId where bfed is not null and bfed.id in (select id from DtFeds) "
				+ "insert into misFEDs select 'backpressure and deadtime' as title, dfed.id as fedId where dfed is not null and dfed.id in (select id from BpFeds) "
				+ "insert into misFEDs select 'backpressure' as title, bfed.id as fedId where bfed is not null and bfed.id is not null "
				+ "insert into misFEDs select 'deadime' as title, dfed.id as fedId where dfed is not null and dfed.id is not null;

		// the best would be just to detect deletions :-( like "on rstream Sth"
on pattern[every timer:interval(1 msec)] delete from Conclusions as c where c.title.toString().contains('backpressure') and "
				+ "c.fedId is not null and c.fedId.toString() not in (select id.toString() from BpFeds);

on pattern[every timer:interval(1 msec)] delete from Conclusions as c where c.title.toString().contains('deadtime') and "
				+ "c.fedId is not null and c.fedId.toString() not in (select id.toString() from DtFeds);

select id.toString() as id from DtFeds", new UpdateListener() {

			@Override
			public void update(EventBean[] newEvents, EventBean[] oldEvents) {
				for (EventBean b : newEvents) {
					console("DtFeds", b.getUnderlying().toString());
				}
			}
		});

select count(*) as suspiciousFeds from BpFeds as bpf, DtFeds as dtf where bpf.id=dtf.id", watchUpdater);

select * from BpFeds", consoleLogger);
select * from DtFeds", consoleLogger);
 **/

