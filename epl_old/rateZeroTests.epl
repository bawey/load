module rateZeroTests;

/** STRUCTURE **/
@Description('')
create variable long deadRateTimeout=10000;

create variable int bxBucketsLimit = 10;
create variable int bxDetailsLimit = 30;

create variable int trgBucketsLimit = 10;
create variable int trgDetailsLimit = 30;

create variable long prevalentBxn = 0;

@Description('Store the L1 zero rates and their timestamps as they come and flush whenever a non-zero comes')
create window L1DeadRates.win:expr(newest_event.rate=0) as select * from L1Rates;



create window ZeroRateTimer.win:length(1) as (elapsed long);

create window PrevalentBxn.win:length(1) as (bxNumber long);


create objectarray schema BxDistribution as (timestamp Long, groups Long);
create objectarray schema TrgDistribution as (timestamp Long, groups Long);
/** LOGIC **/



@Verbose(label="L1DR")
@Description('Store the L1 zero rates and their timestamps as they come and flush whenever a non-zero comes')
insert into L1DeadRates select distinct * from L1Rates;

@Watched(label='deadRateElapsed')
insert into ZeroRateTimer select (case when count(*)>1 then max(timestamp)-min(timestamp) else 0 end) as elapsed 
	from pattern[every L1Rates] unidirectional, L1DeadRates;

insert into BxDistribution select distinct count(distinct ctl.bxNumber) as groups, max(ctl.timestamp.getTime()) as timestamp 
	from pattern[every ZeroRateTimer(elapsed>deadRateTimeout)] unidirectional, FrlCtlLnk.std:unique(fedId) as ctl;


@Priority(10)
@Description('Prepare the prevalent Bx number')
@Verbose(label='BxDistribution', extraNfo='inserting into PrevalentBxn window', fields={'bxNumber'})
insert into PrevalentBxn
select bxNumber from pattern[every BxDistribution(groups>1)] unidirectional, FrlCtlLnk.std:unique(fedId) group by bxNumber having count(*)=max(count(*)) limit 1;

@Priority(10)
@Verbose(label='BxDistribution')
on PrevalentBxn as bxn set prevalentBxn = bxn.bxNumber;

//not sure if this is actually needed
//@Description('reset the bx and trg distributions to n/a when rate > 0')
//on pattern[every a = L1Rates(rate>0)] 
//	insert into BxDistribution select a.timestamp as timestamp, -1 as groups
//	insert into TrgDistrubution select a.timestamp as timestamp, -1 as groups
//output all;


/** OUTPUT **/


@Priority(10)
@Description('First, a message about bx misalignment')
@Verbose(label='BxDistribution', extraNfo='FEDs BX-misalignment alert!', fields={'time','groups'})
select date(timestamp) as time, groups from BxDistribution(groups>1);

@Priority(9)
@Description('Second, a limited list of all the groups')
@Verbose(label='BxDistribution', extraNfo='BX number groups', fields={'time','bxNumber','support'})
select bxNumber, count(fedId) as support, max(timestamp) as time from pattern[every BxDistribution(groups>1)] unidirectional, FrlCtlLnk.std:unique(fedId) 
group by bxNumber limit bxBucketsLimit;

@Priority(8)
@Description("Third, a limited list of misaligned feds")
@Verbose(label='BxDistribution', extraNfo='BX-misaligned FEDs', fields={'time','bxNumber','fedId'})
select fedId, bxNumber, timestamp as time from pattern[every BxDistribution(groups>1)] unidirectional, FrlCtlLnk.std:unique(fedId) 
where cast(bxNumber,long) not in (select bxNumber from PrevalentBxn)  limit bxDetailsLimit;

@Priority(7)
@Verbose(label='BxDistribution')
select bxNumber from pattern[every BxDistribution(groups>1)] unidirectional, PrevalentBxn;





		