/** DEFINE STREAMS, WINDOWS AND VARIABLES **/
create variable long minStuckTime = 10000;

create window RecentL1Rates.win:expr(timestamp>max(timestamp)-minStuckTime) as select * from L1Rates;


create window L1DeadRates.win:expr(newest_event.rate=0) as select * from L1Rates;

@Description('Schema will hold the bxNumber standard deviation calculated when the L1Rate is 0')
create schema DeadL1RateBxStDev as (value double, timestamp long);

create schema DeadL1RateTimer as (elapsed long, timestamp long);

create schema DeadL1RateBxHistogram as (bxNumber long, support long, timestamp long);


/** DEFINE INSERTION / DELETION LOGIC **/

insert into RecentL1Rates select * from L1Rates;
insert into L1DeadRates select * from L1Rates;

insert into DeadL1RateTimer select max(timestamp)-min(timestamp) as elapsed, max(timestamp) as timestamp from L1DeadRates;

@Verbose(label='bxNumbers')
select bxNumber from FrlCtlLnk.std:unique(fedId)
	where (select max(timestamp)-min(timestamp) from L1DeadRates ) > minStuckTime;
	

@Verbose(label='bxNumbers')
select count(distinct bxNumber) as cnt from FrlCtlLnk
	where (select max(timestamp)-min(timestamp) from L1DeadRates ) > minStuckTime;

@Verbose(label='deadRateBxStDev')
select distinct stats.stddev as value, max(feds.timestamp) as timestamp from FrlCtlLnk.std:unique(fedId).stat:uni(bxNumber) as stats, FrlCtlLnk.std:unique(fedId) as feds
	where (select max(timestamp)-min(timestamp) from L1DeadRates ) > minStuckTime
	having stats.stddev > 0;

@Verbose(label='distinct bx numbers')
select count(distinct bxNumber) as bxNumberValues, max(timestamp) as timestamp from FrlCtlLnk.std:unique(fedId)
	where (select max(timestamp)-min(timestamp) from L1DeadRates) > minStuckTime;

@Verbose(label='PatternTriggeredBxAlignmentCheck')
select * from DeadL1RateTimer(elapsed>minStuckTime);


create window ForYourStupidSatisfaction.std:unique(fedId) as select * from FrlCtlLnk;
insert into ForYourStupidSatisfaction select * from FrlCtlLnk;

@Verbose(label='bxHistogram')
on pattern[every DeadL1RateTimer(elapsed>minStuckTime)] insert into DeadL1RateBxHistogram 
	select count(fedId) as support, bxNumber, max(timestamp.getTime()) as timestamp from ForYourStupidSatisfaction group by bxNumber;

@Verbose(label='possible?')
select count(fedId) as support, bxNumber, max(timestamp.getTime()) as timestamp from FrlCtlLnk.std:unique(fedId) group by bxNumber;


@Verbose(label='printMe')
on pattern[every FrlCtlLnk] select current_timestamp() from *;



/** DEFINE OUTPUT PRINTING **/

@Watched(label = 'RecentRatesLength')
select count(*) from RecentL1Rates;

@Watched(label = 'RatesLength')
select count(*) from L1Rates;

@Watched(label='L1DeadRates')
select count(*) from L1DeadRates;

@Watched(label='L1Rates zero for')
select (max(timestamp)-min(timestamp))/1000 from L1DeadRates having max(timestamp) is not null;

@Verbose(label='l1Rates', append=false)
select * from L1Rates;

@Verbose(label='l1Rates')
select count(*) from L1Rates;

//@Watched(label='minRecentRateStamp')
//select min(timestamp) from RecentL1Rates;

//@Verbose(label='L1Rates', append=false)
//select min(timestamp) from L1Rates where timestamp >= (select max(timestamp) from L1Rates);




//measure how long the trigger rate has been 0
// if long enough, check bxNumber and triggerNumber of frlcontrollerLink
// + report on the ones standing out! (unless there is dynamic
// backPressureDyn on them)

@Description('Seconds...')
create variable int stuckTime = 1;
create variable int samplingT = 200;

create window frlBxValues.std:unique(bxNumber).win:time(stuckTime sec) as (bxNumber Long, cnt Long, timestamp Long);
create window frlTrgValues.std:unique(trgNumber).win:time(stuckTime sec) as (trgNumber Long, cnt Long, timestamp Long);

create window frlBuffer.std:unique(slotNumber, context, linkNumber) as select * from frlcontrollerLink;

insert into frlBuffer select * from frlcontrollerLink;


on pattern[every timer:interval(samplingT msec)] 
	insert into frlBxValues select bxNumber as bxNumber, count(*) as cnt, lastever(timestamp.getTime()) as timestamp from frlBuffer group by bxNumber ;
on pattern[every timer:interval(samplingT msec)] 
	insert into frlTrgValues select triggerNumber as trgNumber, count(*) as cnt, lastever(timestamp.getTime()) as timestamp from frlBuffer group by triggerNumber;

on pattern[every timer:interval(samplingT msec)] delete from frlBxValues as fbc where fbc.bxNumber not in (select bxNumber from frlBuffer);
on pattern[every timer:interval(samplingT msec)] delete from frlTrgValues as ftv where ftv.trgNumber not in (select triggerNumber from frlBuffer);

@Watched
on pattern[every timer:interval(stuckTime sec) and not L1Rates(rate>0)] 
	select count(*) as bxNumbers from frlBxValues;
@Watched
on pattern[every timer:interval(stuckTime sec) and not L1Rates(rate>0)] 
	select count(*) as trgNumbers from  frlTrgValues;

@Description('these three should be linked into sth more of a hierarchy')
@Verbose(label='error')
on pattern[every timer:interval(stuckTime sec) and not L1Rates(rate>0)] 
	select 'L1Rates stuck, bxNumbers inconsistent' as problem, count(*) as bxNumbers from frlBxValues where 
	(select count(*) from frlBxValues)>1;

@Verbose(label='error')
on pattern[every timer:interval(stuckTime sec) and not L1Rates(rate>0)]
	select 'L1Rates stuck, triggerNumbers inconsistent' as problem, count(*) as trgNumbers from frlTrgValues where 
	(select count(*) from frlTrgValues)>1;

@Verbose(label='warning', extraNfo='Level one trigger rate stuck at 0', fields={'timeThreshold'})
select stuckTime as timeThreshold from pattern[every timer:interval(stuckTime sec) and not L1Rates(rate>0) ];

@Watched(label='buffered FRL ctl link')
select count(*) from frlBuffer;


@Verbose(label='frlBxValues', streamPath={}, fields={'timestamp','bxNumber','cnt'}, append=false)
on pattern[every timer:interval(stuckTime sec) and not L1Rates(rate>0)] select f.* from frlBxValues as f;
@Verbose(label='frlTrgValues', streamPath={}, fields={'trgNumber', 'cnt', 'timestamp'}, append=false)
on pattern[every timer:interval(stuckTime sec) and not L1Rates(rate>0)] select f.* from frlTrgValues as f;

@Verbose(label='insertedBx')
select * from frlBxValues;

@Verbose(label='insertedTrg')
select * from frlTrgValues;

